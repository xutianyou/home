<!DOCTYPE html>
<html>
<head>
  <title></title>
</head>
<body>
<script type="text/javascript">
// let symbol1 = Symbol();
// let symbol2 = Symbol();
// console.log(typeof(symbol1))
// console.log(typeof(symbol2))
// console.log(symbol1 === symbol2)

// let symbol = Symbol();
// let a = {
//   [symbol]: 'web'
// }
// console.log(a[symbol])

// let symbol3 = Symbol();
// let b = {}
// Object.defineProperty(b, symbol, {
//   value: 'web'
// })
// console.log(b[symbol])

// let symbol4 = Symbol('web');
// console.log('symbol4', symbol4)
// console.log('symbol4', symbol4.toString())
// console.log(Object.getOwnPropertySymbols(a))
// console.log(Object.getOwnPropertySymbols(b))


var o = {
  name: 'gcc',
}

//1. 唯一Symbol，常用于为对象添加新属性，避免覆盖
let s1 = Symbol('s1')

o[s1] = 's1val'

//常规遍历不能得到Symbol属性名
for(let tmp in o)
  console.log('for:', o[tmp])
  
//Object.getOwnPropertySymbol可以得到所有Symbol属性名，弊端是不能获取非Symbol属性名
let oSymbolNames = Object.getOwnPropertySymbols(o)
console.log('oSymbolNames', oSymbolNames)

//Reflect.ownKeys能获取所有属性名
let oAllNames = Reflect.ownKeys(o)
console.log('oAllNames', oAllNames)

//则遍历应为
for(let tmp of Reflect.ownKeys(o))
  console.log('for.Reflect:', o[tmp])
  
//复用Symbol值，全局定义Symbol
let s2 = Symbol.for('s1')
let s3 = Symbol.for('s1')

console.log(s2 === s3) //true
console.log(s1 === s2) //false

//获取定义名，必须全局定义
console.log(Symbol.keyFor(s1))  //undefined
console.log(Symbol.keyFor(s2))  //s1
console.log(Symbol.keyFor(s3))  //s1

</script>
</body>
</html>